/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NotionSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// notion/notion-client.ts
var import_obsidian = require("obsidian");
var NotionClient = class {
  constructor(token) {
    this.token = token;
  }
  /**
   * Método para manter compatibilidade com o código existente
   */
  getClient() {
    console.warn("getClient() est\xE1 deprecado, use os m\xE9todos diretos");
    return {
      pages: {
        create: async (data) => {
          return await this.obsidianRequest("/pages", "POST", data);
        },
        update: async (data) => {
          return await this.obsidianRequest(
            `/pages/${data.page_id}`,
            "PATCH",
            data
          );
        },
        retrieve: async (data) => {
          return await this.obsidianRequest(`/pages/${data.page_id}`, "GET");
        }
      },
      blocks: {
        children: {
          list: async (data) => {
            return await this.obsidianRequest(
              `/blocks/${data.block_id}/children`,
              "GET"
            );
          },
          append: async (data) => {
            return await this.obsidianRequest(
              `/blocks/${data.block_id}/children`,
              "PATCH",
              data
            );
          }
        },
        delete: async (data) => {
          return await this.obsidianRequest(
            `/blocks/${data.block_id}`,
            "DELETE"
          );
        }
      },
      users: {
        me: async () => {
          return await this.obsidianRequest("/users/me", "GET");
        }
      }
    };
  }
  /**
   * Método auxiliar para fazer requisições via Obsidian requestUrl
   * para evitar problemas de CORS
   */
  async obsidianRequest(endpoint, method, body) {
    const url = `https://api.notion.com/v1${endpoint}`;
    console.log(`Fazendo requisi\xE7\xE3o ${method} para ${url}`);
    try {
      const params = {
        url,
        method,
        headers: {
          Authorization: `Bearer ${this.token}`,
          "Notion-Version": "2022-06-28",
          "Content-Type": "application/json"
        },
        contentType: "application/json",
        body: body ? JSON.stringify(body) : void 0
      };
      console.log("Par\xE2metros da requisi\xE7\xE3o:", JSON.stringify(params, null, 2));
      const response = await (0, import_obsidian.requestUrl)(params);
      console.log(`Resposta recebida com status ${response.status}`);
      return response.json;
    } catch (error) {
      console.error(`Erro na requisi\xE7\xE3o para ${url}:`, error);
      throw error;
    }
  }
  /**
   * Testa a conexão com a API do Notion
   */
  async testConnection() {
    try {
      console.log("Testando conex\xE3o com Notion...");
      console.log(
        "Usando token:",
        this.token ? `${this.token.substring(0, 4)}...` : "indefinido"
      );
      const response = await this.obsidianRequest("/users/me", "GET");
      console.log("API Response:", response);
      return true;
    } catch (error) {
      console.error("Erro de conex\xE3o:", error);
      return false;
    }
  }
  /**
   * Cria uma nova página no Notion usando requestUrl do Obsidian
   */
  async createPage(parentPageId, title, blocks) {
    try {
      console.log(`Criando p\xE1gina "${title}" no parent ${parentPageId}`);
      const data = {
        parent: {
          page_id: parentPageId
        },
        properties: {
          title: {
            title: [
              {
                text: {
                  content: title
                }
              }
            ]
          }
        },
        children: blocks
      };
      const response = await this.obsidianRequest("/pages", "POST", data);
      console.log(`P\xE1gina criada com sucesso, ID: ${response.id}`);
      return response.id;
    } catch (error) {
      console.error(
        `Erro ao criar p\xE1gina "${title}" em ${parentPageId}:`,
        error
      );
      throw error;
    }
  }
  /**
   * Obtém informações sobre uma página do Notion
   */
  async getPage(pageId) {
    try {
      return await this.obsidianRequest(`/pages/${pageId}`, "GET");
    } catch (error) {
      console.error(`Erro ao obter p\xE1gina ${pageId}:`, error);
      throw error;
    }
  }
  /**
   * Atualiza o conteúdo de uma página existente
   */
  async updatePageContent(pageId, content) {
    try {
      console.log(`Atualizando conte\xFAdo da p\xE1gina ${pageId}`);
      await this.clearAllBlocks(pageId);
      const blocks = [
        {
          object: "block",
          type: "paragraph",
          paragraph: {
            rich_text: [
              {
                type: "text",
                text: {
                  content
                }
              }
            ]
          }
        }
      ];
      await this.obsidianRequest(`/blocks/${pageId}/children`, "PATCH", {
        children: blocks
      });
      console.log(`Conte\xFAdo da p\xE1gina atualizado com sucesso`);
    } catch (error) {
      console.error(`Erro ao atualizar conte\xFAdo da p\xE1gina ${pageId}:`, error);
      throw error;
    }
  }
  /**
   * Obtém todos os blocos de uma página
   */
  async getBlocks(pageId) {
    try {
      return await this.obsidianRequest(`/blocks/${pageId}/children`, "GET");
    } catch (error) {
      console.error(`Erro ao obter blocos da p\xE1gina ${pageId}:`, error);
      throw error;
    }
  }
  /**
   * Remove todos os blocos de uma página
   */
  async clearAllBlocks(pageId) {
    try {
      console.log(`Limpando blocos da p\xE1gina ${pageId}`);
      const response = await this.getBlocks(pageId);
      console.log(`Encontrados ${response.results.length} blocos para remover`);
      for (const block of response.results) {
        await this.obsidianRequest(`/blocks/${block.id}`, "DELETE");
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      console.log(`Todos os blocos removidos com sucesso`);
    } catch (error) {
      console.error(`Erro ao limpar blocos da p\xE1gina ${pageId}:`, error);
      throw error;
    }
  }
  /**
   * Cria uma página de pasta no Notion
   */
  async createFolderPage(parentId, folderName) {
    try {
      console.log(`Criando pasta "${folderName}" no parent ${parentId}`);
      const data = {
        parent: {
          page_id: parentId
        },
        properties: {
          title: {
            title: [
              {
                text: {
                  content: folderName
                }
              }
            ]
          }
        },
        children: [
          {
            object: "block",
            type: "paragraph",
            paragraph: {
              rich_text: [
                {
                  type: "text",
                  text: {
                    content: `Pasta sincronizada do Obsidian: ${folderName}`
                  }
                }
              ]
            }
          }
        ]
      };
      const response = await this.obsidianRequest("/pages", "POST", data);
      console.log(`Pasta criada com sucesso, ID: ${response.id}`);
      return response.id;
    } catch (error) {
      console.error(`Erro ao criar pasta ${folderName} em ${parentId}:`, error);
      throw error;
    }
  }
};

// notion/notion-utils.ts
function markdownToNotionBlocks(markdownContent) {
  const blocks = [];
  const lines = markdownContent.split("\n");
  let currentParagraph = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith("# ")) {
      if (currentParagraph) {
        blocks.push(createParagraphBlock(currentParagraph));
        currentParagraph = "";
      }
      blocks.push(createHeadingBlock(line.substring(2), 1));
      continue;
    }
    if (line.startsWith("## ")) {
      if (currentParagraph) {
        blocks.push(createParagraphBlock(currentParagraph));
        currentParagraph = "";
      }
      blocks.push(createHeadingBlock(line.substring(3), 2));
      continue;
    }
    if (line.startsWith("### ")) {
      if (currentParagraph) {
        blocks.push(createParagraphBlock(currentParagraph));
        currentParagraph = "";
      }
      blocks.push(createHeadingBlock(line.substring(4), 3));
      continue;
    }
    if (line.match(/^\s*[-*+]\s/)) {
      if (currentParagraph) {
        blocks.push(createParagraphBlock(currentParagraph));
        currentParagraph = "";
      }
      const itemContent = line.replace(/^\s*[-*+]\s/, "");
      blocks.push(createBulletListBlock(itemContent));
      continue;
    }
    if (line.match(/^\s*\d+\.\s/)) {
      if (currentParagraph) {
        blocks.push(createParagraphBlock(currentParagraph));
        currentParagraph = "";
      }
      const itemContent = line.replace(/^\s*\d+\.\s/, "");
      blocks.push(createNumberedListBlock(itemContent));
      continue;
    }
    if (line.startsWith("```")) {
      if (currentParagraph) {
        blocks.push(createParagraphBlock(currentParagraph));
        currentParagraph = "";
      }
      const language = line.substring(3).trim();
      let codeContent = "";
      let j = i + 1;
      while (j < lines.length && !lines[j].startsWith("```")) {
        codeContent += lines[j] + "\n";
        j++;
      }
      blocks.push(createCodeBlock(codeContent, language));
      i = j;
      continue;
    }
    if (line.trim() === "") {
      if (currentParagraph) {
        blocks.push(createParagraphBlock(currentParagraph));
        currentParagraph = "";
      }
      continue;
    }
    if (currentParagraph) {
      currentParagraph += "\n" + line;
    } else {
      currentParagraph = line;
    }
  }
  if (currentParagraph) {
    blocks.push(createParagraphBlock(currentParagraph));
  }
  return blocks;
}
function createParagraphBlock(content) {
  return {
    object: "block",
    type: "paragraph",
    paragraph: {
      rich_text: [
        {
          type: "text",
          text: {
            content
          }
        }
      ]
    }
  };
}
function createHeadingBlock(content, level) {
  const headingType = `heading_${level}`;
  return {
    object: "block",
    type: headingType,
    [headingType]: {
      rich_text: [
        {
          type: "text",
          text: {
            content
          }
        }
      ]
    }
  };
}
function createBulletListBlock(content) {
  return {
    object: "block",
    type: "bulleted_list_item",
    bulleted_list_item: {
      rich_text: [
        {
          type: "text",
          text: {
            content
          }
        }
      ]
    }
  };
}
function createNumberedListBlock(content) {
  return {
    object: "block",
    type: "numbered_list_item",
    numbered_list_item: {
      rich_text: [
        {
          type: "text",
          text: {
            content
          }
        }
      ]
    }
  };
}
function createCodeBlock(content, language = "") {
  return {
    object: "block",
    type: "code",
    code: {
      rich_text: [
        {
          type: "text",
          text: {
            content
          }
        }
      ],
      language: language || "plain text"
    }
  };
}
function processMarkdownFrontmatter(content) {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = content.match(frontmatterRegex);
  if (!match) {
    return {
      metadata: {},
      content
    };
  }
  const frontmatter = match[1];
  const mainContent = match[2];
  const metadata = {};
  const lines = frontmatter.split("\n");
  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex !== -1) {
      const key = line.substring(0, colonIndex).trim();
      const value = line.substring(colonIndex + 1).trim();
      metadata[key] = value.replace(/^["'](.*)["']$/, "$1");
    }
  }
  return {
    metadata,
    content: mainContent
  };
}

// notion/notion-sync-service.ts
var NotionSyncService = class {
  constructor(notionToken, rootPageId) {
    this.pageCache = {};
    this.notionClient = new NotionClient(notionToken);
    this.rootPageId = rootPageId;
  }
  /**
   * Sincroniza arquivos do Obsidian com o Notion
   */
  async syncFilesToNotion(files, vault) {
    const isConnected = await this.notionClient.testConnection();
    if (!isConnected) {
      throw new Error(
        "Falha na conex\xE3o com a API do Notion. Verifique seu token."
      );
    }
    await this.ensureFolderStructure(files);
    for (const file of files) {
      try {
        const content = await vault.read(file.file);
        const { metadata, content: processedContent } = processMarkdownFrontmatter(content);
        const blocks = markdownToNotionBlocks(processedContent);
        if (this.pageCache[file.path]) {
          await this.updateNotionPage(
            this.pageCache[file.path],
            file.name,
            blocks
          );
        } else {
          const parentId = this.getParentPageId(file.parent);
          if (!parentId) {
            console.warn(`Pai n\xE3o encontrado para ${file.path}, usando raiz`);
          }
          const notionPageId = await this.createNotionPage(
            parentId || this.rootPageId,
            file.name,
            blocks,
            metadata
          );
          this.pageCache[file.path] = notionPageId;
        }
      } catch (error) {
        console.error(`Erro ao sincronizar arquivo ${file.path}:`, error);
      }
    }
  }
  /**
   * Garante que a estrutura de pastas exista no Notion
   */
  async ensureFolderStructure(files) {
    const folders = /* @__PURE__ */ new Set();
    for (const file of files) {
      if (file.parent) {
        const parts = file.parent.split("/");
        let currentPath = "";
        for (let i = 0; i < parts.length; i++) {
          if (parts[i]) {
            if (currentPath) {
              currentPath += "/";
            }
            currentPath += parts[i];
            folders.add(currentPath);
          }
        }
      }
    }
    const sortedFolders = Array.from(folders).sort(
      (a, b) => (a.match(/\//g) || []).length - (b.match(/\//g) || []).length
    );
    for (const folderPath of sortedFolders) {
      try {
        const parts = folderPath.split("/");
        const folderName = parts[parts.length - 1];
        if (parts.length === 1) {
          if (!this.pageCache[folderPath]) {
            const notionPageId = await this.createFolderPage(
              this.rootPageId,
              folderName
            );
            this.pageCache[folderPath] = notionPageId;
          }
        } else {
          const parentPath = parts.slice(0, -1).join("/");
          const parentId = this.pageCache[parentPath];
          if (parentId) {
            if (!this.pageCache[folderPath]) {
              const notionPageId = await this.createFolderPage(
                parentId,
                folderName
              );
              this.pageCache[folderPath] = notionPageId;
            }
          } else {
            console.warn(
              `Pasta pai n\xE3o encontrada para ${folderPath}, usando raiz`
            );
            const notionPageId = await this.createFolderPage(
              this.rootPageId,
              folderName
            );
            this.pageCache[folderPath] = notionPageId;
          }
        }
      } catch (error) {
        console.error(`Erro ao criar estrutura para ${folderPath}:`, error);
      }
    }
  }
  /**
   * Cria uma página de pasta no Notion
   */
  async createFolderPage(parentId, folderName) {
    try {
      const response = await this.notionClient.getClient().pages.create({
        parent: {
          page_id: parentId
        },
        properties: {
          title: {
            title: [
              {
                text: {
                  content: folderName
                }
              }
            ]
          }
        },
        children: [
          {
            object: "block",
            type: "paragraph",
            paragraph: {
              rich_text: [
                {
                  type: "text",
                  text: {
                    content: `Pasta sincronizada do Obsidian: ${folderName}`
                  }
                }
              ]
            }
          }
        ]
      });
      return response.id;
    } catch (error) {
      console.error(`Erro ao criar pasta ${folderName} em ${parentId}:`, error);
      throw error;
    }
  }
  /**
   * Cria uma página de nota no Notion
   */
  async createNotionPage(parentId, title, blocks, metadata = {}) {
    try {
      const properties = {
        title: {
          title: [
            {
              text: {
                content: title
              }
            }
          ]
        }
      };
      for (const [key, value] of Object.entries(metadata)) {
        if (!key.trim())
          continue;
        properties[key] = {
          rich_text: [
            {
              type: "text",
              text: {
                content: String(value)
              }
            }
          ]
        };
      }
      const response = await this.notionClient.getClient().pages.create({
        parent: {
          page_id: parentId
        },
        properties,
        children: blocks
      });
      return response.id;
    } catch (error) {
      console.error(`Erro ao criar p\xE1gina ${title} em ${parentId}:`, error);
      throw error;
    }
  }
  /**
   * Atualiza uma página existente no Notion
   */
  async updateNotionPage(pageId, title, blocks) {
    try {
      await this.notionClient.getClient().pages.update({
        page_id: pageId,
        properties: {
          title: {
            title: [
              {
                text: {
                  content: title
                }
              }
            ]
          }
        }
      });
      await this.clearAllBlocks(pageId);
      await this.notionClient.getClient().blocks.children.append({
        block_id: pageId,
        children: blocks
      });
    } catch (error) {
      console.error(`Erro ao atualizar p\xE1gina ${pageId}:`, error);
      throw error;
    }
  }
  /**
   * Remove todos os blocos de uma página
   */
  async clearAllBlocks(pageId) {
    try {
      const response = await this.notionClient.getClient().blocks.children.list({
        block_id: pageId
      });
      for (const block of response.results) {
        await this.notionClient.getClient().blocks.delete({
          block_id: block.id
        });
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    } catch (error) {
      console.error(`Erro ao limpar blocos da p\xE1gina ${pageId}:`, error);
      throw error;
    }
  }
  /**
   * Obtém o ID da página pai com base no caminho
   */
  getParentPageId(parentPath) {
    if (!parentPath || parentPath === "") {
      return this.rootPageId;
    }
    return this.pageCache[parentPath] || null;
  }
};

// utils/vault-scanner.ts
async function scanVault(vault, excludeFolders = []) {
  const files = [];
  const markdownFiles = vault.getMarkdownFiles();
  for (const file of markdownFiles) {
    if (isInExcludedFolder(file.path, excludeFolders)) {
      continue;
    }
    const pathParts = file.path.split("/");
    const fileName = pathParts.pop() || "";
    const parentPath = pathParts.join("/");
    files.push({
      file,
      path: file.path,
      name: fileName.replace(".md", ""),
      parent: parentPath
    });
  }
  return files;
}
function isInExcludedFolder(path, excludeFolders) {
  return excludeFolders.some(
    (folder) => path === folder || path.startsWith(folder + "/")
  );
}

// settings/plugin-settings.ts
var DEFAULT_SETTINGS = {
  notionToken: "",
  rootPageId: "",
  syncOnSave: false,
  excludeFolders: [],
  lastSyncTimestamp: 0
};

// settings/settings-tab.ts
var import_obsidian2 = require("obsidian");
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Notion Sync Settings" });
    new import_obsidian2.Setting(containerEl).setName("Notion API Token").setDesc("Notion integration token. Get it at https://www.notion.so/my-integrations").addText((text) => text.setPlaceholder("Secret_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx").setValue(this.plugin.settings.notionToken).onChange(async (value) => {
      this.plugin.settings.notionToken = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Root Page ID").setDesc("ID of the Notion page where structure will be synced (format: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx)").addText((text) => text.setPlaceholder("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx").setValue(this.plugin.settings.rootPageId).onChange(async (value) => {
      this.plugin.settings.rootPageId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Sync on save").setDesc("Automatically sync notes with Notion when they are saved").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnSave).onChange(async (value) => {
      this.plugin.settings.syncOnSave = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Excluded folders").setDesc("List of folders to exclude from syncing (comma separated)").addText((text) => text.setPlaceholder("folder1, folder2/subfolder").setValue(this.plugin.settings.excludeFolders.join(", ")).onChange(async (value) => {
      this.plugin.settings.excludeFolders = value.split(",").map((folder) => folder.trim()).filter((folder) => folder);
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Help & Information" });
    const infoDiv = containerEl.createEl("div", { cls: "setting-item-info" });
    infoDiv.createEl("p", { text: "To use this plugin:" });
    const ul = infoDiv.createEl("ul");
    ul.createEl("li", { text: "1. Create a Notion integration and get the API token." });
    ul.createEl("li", { text: "2. Share a Notion page with your integration (in the Notion interface)." });
    ul.createEl("li", { text: "3. Get the ID of the shared page from the URL." });
    ul.createEl("li", { text: '4. Configure the options above and use the "Sync to Notion" command.' });
    const lastSyncDiv = containerEl.createEl("div", { cls: "setting-item" });
    if (this.plugin.settings.lastSyncTimestamp) {
      const date = new Date(this.plugin.settings.lastSyncTimestamp);
      lastSyncDiv.createEl("p", { text: `Last sync: ${date.toLocaleString()}` });
    } else {
      lastSyncDiv.createEl("p", { text: "No sync performed yet." });
    }
  }
};

// main.ts
function normalizeNotionPageId(input) {
  if (input.includes("notion.so")) {
    const match = input.match(
      /([a-f0-9]{32})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/i
    );
    if (match) {
      return match[0].replace(/-/g, "");
    }
  }
  return input.replace(/[^a-f0-9]/gi, "");
}
var NotionSyncPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("\u{1F7E1} Plugin Notion Sync carregando...");
    await this.loadSettings();
    if (this.settings.notionToken && this.settings.rootPageId) {
      const cleanPageId = normalizeNotionPageId(this.settings.rootPageId);
      this.notionSyncService = new NotionSyncService(
        this.settings.notionToken,
        cleanPageId
      );
      console.log("\u2705 Servi\xE7o do Notion inicializado.");
    } else {
      console.warn("\u26A0\uFE0F Token ou Root Page ID n\xE3o configurados.");
    }
    this.addCommand({
      id: "sync-to-notion",
      name: "Sync to Notion",
      callback: async () => {
        console.log("\u{1F680} Comando 'Sync to Notion' iniciado...");
        if (!this.settings.notionToken || !this.settings.rootPageId) {
          new import_obsidian3.Notice(
            "Please configure the Notion API token and Root Page ID in the plugin settings."
          );
          return;
        }
        try {
          new import_obsidian3.Notice("Starting synchronization with Notion...");
          const files = await scanVault(
            this.app.vault,
            this.settings.excludeFolders
          );
          console.log(`\u{1F4C1} Arquivos encontrados para sync: ${files.length}`);
          await this.notionSyncService.syncFilesToNotion(files, this.app.vault);
          this.settings.lastSyncTimestamp = Date.now();
          await this.saveSettings();
          console.log("\u2705 Sincroniza\xE7\xE3o conclu\xEDda com sucesso.");
          new import_obsidian3.Notice("Notion synchronization completed successfully!");
        } catch (error) {
          console.error("\u274C Erro durante sincroniza\xE7\xE3o:", error);
          new import_obsidian3.Notice(`Sync error: ${error.message}`);
        }
      }
    });
    this.addSettingTab(new SettingsTab(this.app, this));
    if (this.settings.syncOnSave) {
      console.log("\u{1F501} Auto-sync ativado. Escutando modifica\xE7\xF5es...");
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          if (!(file instanceof import_obsidian3.TFile) || file.extension !== "md")
            return;
          if (!this.settings.syncOnSave)
            return;
          if (!this.settings.notionToken || !this.settings.rootPageId)
            return;
          if (this.settings.excludeFolders.some(
            (folder) => file.path === folder || file.path.startsWith(folder + "/")
          )) {
            return;
          }
          try {
            const pathParts = file.path.split("/");
            const parentPath = pathParts.slice(0, -1).join("/");
            const vaultFile = {
              file,
              path: file.path,
              name: file.basename,
              parent: parentPath
            };
            console.log(`\u{1F4CC} Auto-sync para o arquivo: ${file.path}`);
            await this.notionSyncService.syncFilesToNotion(
              [vaultFile],
              this.app.vault
            );
            new import_obsidian3.Notice(`File "${file.basename}" synced to Notion`);
          } catch (error) {
            console.error(
              `\u274C Erro ao sincronizar automaticamente ${file.path}:`,
              error
            );
          }
        })
      );
    }
  }
  onunload() {
    console.log("\u{1F534} Plugin Notion Sync descarregado.");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    console.log("\u2699\uFE0F Configura\xE7\xF5es carregadas:", this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.settings.notionToken && this.settings.rootPageId) {
      const cleanPageId = normalizeNotionPageId(this.settings.rootPageId);
      this.notionSyncService = new NotionSyncService(
        this.settings.notionToken,
        cleanPageId
      );
      console.log("\u2705 Servi\xE7o do Notion reinicializado ap\xF3s salvar configs.");
    }
  }
};
